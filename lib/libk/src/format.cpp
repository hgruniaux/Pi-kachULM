/* Generated by re2c */
#include "format_impl.hpp"

#include <libk/assert.hpp>

namespace libk::detail {
static size_t parse_index(const char* it) {
  size_t index = 0;
  while (*it >= '0' && *it <= '9') {
    index *= 10;
    index += *it - '0';
    ++it;
  }
  return index;
}

char* format_to(char* out, const char* fmt, const Argument* args, size_t args_count) {
  size_t next_argument_index = 0;
#define CHECK_ARGUMENT_INDEX(index) KASSERT((index) < args_count);

  // Variables needed by re2c
  const char* YYCURSOR = fmt;
  const char* YYMARKER = nullptr;

  // User-defined tag variables that are available in semantic action.
  const char *index_ptr, *spec_ptr;

  const char *yyt1;
const char *yyt2;


  while (true) {
    
{
	char yych;
	static const unsigned char yybm[] = {
		  0, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		192, 192, 192, 192, 192, 192, 192, 192, 
		192, 192, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128,   0, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
		128, 128, 128, 128, 128, 128, 128, 128, 
	};
	yych = *YYCURSOR;
	if (yych <= '{') {
		if (yych <= 0x00) goto yy1;
		if (yych <= 'z') goto yy2;
		goto yy4;
	} else {
		if (yych == '}') goto yy5;
		goto yy2;
	}
yy1:
	++YYCURSOR;
	{ break; }
yy2:
	++YYCURSOR;
yy3:
	{ *out++ = yych; continue; }
yy4:
	yych = *(YYMARKER = ++YYCURSOR);
	if (yych <= 'z') {
		if (yych <= '/') goto yy3;
		if (yych <= '9') {
			yyt1 = YYCURSOR;
			goto yy6;
		}
		if (yych <= ':') {
			yyt1 = NULL;
			goto yy8;
		}
		goto yy3;
	} else {
		if (yych <= '{') goto yy9;
		if (yych == '}') {
			yyt1 = yyt2 = NULL;
			goto yy10;
		}
		goto yy3;
	}
yy5:
	yych = *++YYCURSOR;
	if (yych == '}') goto yy11;
	goto yy3;
yy6:
	yych = *++YYCURSOR;
	if (yybm[0+yych] & 64) {
		goto yy6;
	}
	if (yych <= '/') goto yy7;
	if (yych <= ':') goto yy8;
	if (yych == '}') {
		yyt2 = NULL;
		goto yy10;
	}
yy7:
	YYCURSOR = YYMARKER;
	goto yy3;
yy8:
	yych = *++YYCURSOR;
	if (yych <= 0x00) goto yy7;
	if (yych == '}') {
		yyt2 = YYCURSOR;
		goto yy10;
	}
	yyt2 = YYCURSOR;
	goto yy12;
yy9:
	++YYCURSOR;
	{ *out++ = '{'; continue; }
yy10:
	++YYCURSOR;
	index_ptr = yyt1;
	spec_ptr = yyt2;
	{
          const size_t index = (index_ptr == nullptr) ? next_argument_index++ : parse_index(index_ptr);
          CHECK_ARGUMENT_INDEX(index);
          out = format_argument_to(out, args[index], spec_ptr);
          continue;
        }
yy11:
	++YYCURSOR;
	{ *out++ = '}'; continue; }
yy12:
	yych = *++YYCURSOR;
	if (yybm[0+yych] & 128) {
		goto yy12;
	}
	if (yych <= 0x00) goto yy7;
	goto yy10;
}

  }

  return out;
}
}  // namespace libk::detail
